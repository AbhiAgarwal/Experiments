/* * mm-naive.c - The fastest, least memory-efficient malloc package. *  * In this naive approach, a block is allocated by simply incrementing * the brk pointer.  A block is pure payload. There are no headers or * footers.  Blocks are never coalesced or reused. Realloc is * implemented directly using mm_malloc and mm_free. * * NOTE TO STUDENTS: Replace this header comment with your own header * comment that gives a high level description of your solution. */#include <stdio.h>#include <stdlib.h>#include <assert.h>#include <unistd.h>#include <string.h>#include "mm.h"#include "memlib.h"/********************************************************* * NOTE TO STUDENTS: Before you do anything else, please * replace the first three fields in the following struct * with your own information (you may choose your own * "team name").  Leave the last two feilds blank. ********************************************************/team_t team = {	/* Team name */	"instructors",	/* First member's full name */	"Abhi Agarwal",	/* First member's NYU NetID*/	"ama684@nyu.edu",	/* Second member's full name (leave blank if none) */	"Max Dumas",	/* Second member's email address (leave blank if none) */	"mfd271@nyu.edu"};/* single word (4) or double word (8) alignment */#define ALIGNMENT 8#define WSIZE     4#define DSIZE	  8#define CHUNKSIZE (1 << 12)#define LISTS     5 // LIST SIZES#define LIST1     50 #define LIST2     1000#define LIST3     4000#define LIST4     8000#define LIST5     12000// LIST POSITIONS#define LIST1P     0 #define LIST2P     8#define LIST3P     16#define LIST4P     32#define LIST5P     40/* Macros *//* rounds up to the nearest multiple of ALIGNMENT */#define ALIGN(size) (((size) + (ALIGNMENT-1)) & ~0x7)#define PACK(size, alloc)   ((size) | (alloc))#define MAX(x, y)   ((x) > (y) ? (x) : (y))#define MIN(x, y)   ((x) < (y) ? (x) : (y))#define GET(p)      (*((size_t*) (p)))#define PUT(p, val) (*((size_t*) (p)) = (val))#define GET_SIZE(p)         (GET(p) & ~0x7)#define GET_ALLOC(p)        (GET(p) & 0x1)#define HDRP(bp)    ((char*)(bp) - WSIZE)#define FTRP(bp)    ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)#define NEXT_BLKP(bp)   ((char*)(bp) + GET_SIZE((char*)(bp) - WSIZE))#define PREV_BLKP(bp)   ((char*)(bp) - GET_SIZE((char*)(bp) - DSIZE))#define FREE_NEXT_ADD(bp)   ((char*) ((char*)(bp)))      #define FREE_PREV_ADD(bp)   ((char*) ((char*)(bp) + DSIZE))#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))static void *heap;static void *heap_end;static void *coalesce(void *bp);static void *expand_heap(size_t words);static void merge(void *bp);/*  * mm_init - initialize the malloc package. */int mm_init(void){	// printf("Init called\n");	// Get the address of the beginning of the heap, also expand the heap for our initial padding.	heap = mem_sbrk(4 * WSIZE);	// Check if we failed to expand the heap.	if(((long) heap) == -1)		return -1;	// printf("We've started the heap!\n");	// Put some 1-word long block padding to eliminate edge cases.	PUT(heap, 0);	PUT(heap + (1 * WSIZE), PACK(DSIZE, 1));	PUT(heap + (2 * WSIZE), PACK(DSIZE, 1));	// Advance the heap to put us at the first "real" block of memory.	heap += 2 * WSIZE;	// printf("We've put in the padding and the heap pointer now points to the first useable address!\n");	PUT(heap + (1 * WSIZE), PACK(0, 1)); 	// Epilogue, marks the end of the heap. Once again to avoid edge cases.	heap_end = heap + WSIZE;	// printf("The epilogue and heap end have been set, make sure they are equal: %lu -> %lu\n", (long)heap_end, (long)(heap + WSIZE));	// Extend the heap by the chunksize (or at least as close as we can be to it	// and maintain alignment) 	if(expand_heap(CHUNKSIZE/WSIZE) == NULL) 	{		// printf("Blast! expand_heap must have failed in mm_init!\n");		return -1;	}	else 	{		// printf("The heap was expanded, all is well!\n");		return 0;	}}/*  * mm_malloc - Allocate a block by incrementing the brk pointer. *     Always allocate a block whose size is a multiple of the alignment. */void *mm_malloc(size_t size){	// printf("Malloc called!\n");	if(size <= 0) return NULL;	size_t desir_size;	if(size <= DSIZE) 	// If the user wants a block smaller than a double-word, not possible. Give them the minimum.		desir_size = 2 * DSIZE; // Which happens to be the header, 2 word payload, then the footer.	else // Otherwise add to the size the cost of our header/footer, then ensure it maintains alignment.		desir_size = ALIGN(size + DSIZE);	// Now find the first block that fits, and get us the pointer for that!	void *bp = heap + DSIZE; // Get the first payload	// printf("Searching for block...\n");	// printf("Heap end is: %lu\nDesired size is: %d\n", (long)heap_end, desir_size);	// printf("BP: %lu | ALLOC: %d | SIZE: %d\n", (long)bp, GET_ALLOC(HDRP(bp)), GET_SIZE(HDRP(bp)));	// While the current block is either too small or allocated, and we are inside the heap...	while((GET_ALLOC(HDRP(bp)) || desir_size > GET_SIZE(HDRP(bp))) && bp < heap_end)	{		bp = NEXT_BLKP(bp); // Move to the next one!		// printf("BP: %lu | ALLOC: %d | SIZE: %d HEAP_END: %lu\n", (long)bp, GET_ALLOC(HDRP(bp)), GET_SIZE(HDRP(bp)), (long) heap_end);	}	// printf("We got to the end of the heap or found a block!\n");	// If we reached the end of the heap, then there was no chunk large enough for the	// desired size. So we then allocate a new chunk of CHUNKSIZE or desired size, whichever is bigger.	if(bp >= heap_end) 	{		bp = expand_heap(MAX(desir_size, CHUNKSIZE) / WSIZE);		if(bp == NULL) return NULL;	}	size_t block_size = GET_SIZE(HDRP(bp));	if(block_size > desir_size) // If this, then we have external fragmentation, we need to	{	// split the found block		PUT(bp + desir_size - WSIZE, PACK(block_size - desir_size, 0)); // Set the header of the free block		PUT(FTRP(bp), PACK(block_size - desir_size, 0)); // Update the footer of the free block		PUT(bp + desir_size - DSIZE, PACK(desir_size, 1)); // Set the footer of the block we are allocating		PUT(HDRP(bp), PACK(desir_size, 1)); // Update the header of the block we are allocating				coalesce(bp+desir_size);	}	else // the block and desired size are the same (THIS MAY NOT BE NECESSARY; 		 // THE ABOVE CODE MAY STILL WORK IN THIS SCENARIO)	{		PUT(HDRP(bp), PACK(desir_size, 1)); // Set header to the new size 		// (should be the same as the old), but make it allocated.		PUT(FTRP(bp), PACK(desir_size, 1)); // Do likewise with the footer.	}	// printf("Malloc reached its end.\n");	return bp;}/* * mm_free - Freeing a block does nothing. */void mm_free(void *bp){	// printf("Free called! BP: %lu\n", (long) bp);	if(bp == NULL)		return;	size_t size;	void *nextblock;	void *hdnextblock;	size = GET_SIZE(HDRP(bp));	nextblock = NEXT_BLKP(bp); //noimportante	hdnextblock = HDRP(nextblock); //noimportante	PUT(HDRP(bp), PACK(size, 0));	PUT(FTRP(bp), PACK(size, 0));	coalesce(bp);}/*Returns a pointer to an allocated region of atleast (SIZE) byteswith the following constraints:	- If BP is null call the equivalent mmalloc(size) 	- If SIZE == 0 equivalent mm_free bp	- If BP is not null, realloc changes the size of the memory block pointed 		to by BP to size bytes and returns the address of the new block	- The contents of the new block are the same as those of the oldblock (BP)		OR up to the minumum of the old and new sizes  */void *mm_realloc(void *bp, size_t size){    void *newbp;    void *oldbp = bp;    size_t csize;    if (oldbp == NULL){        return mm_malloc(size);    }    if (size == 0){        mm_free(oldbp);        return NULL;    }            newbp = mm_malloc(size);    csize = MIN(size, GET_SIZE(HDRP(oldbp)));    memmove(newbp, oldbp, csize);    mm_free(oldbp);    	return newbp;}void *expand_heap(size_t words){	// printf("Running Expand Heap\n");	void *bp; // Points to the free block we will be allocating.	size_t size;	// If an uneven number of words is being allocated, make it even.	// Because ALIGNMENT is 8, have an uneven number of words would mean non-multiples of 8 and break alignment.	if(words % 2 != 0) 		++words;		size = words * WSIZE;	// printf("expand_heap: words: %d | size: %d\n", words, size);	bp = mem_sbrk(size); // Expand the heap by size, get the pointer to the old end of the heap.	if(((long)bp) == -1) // If we failed to expand the heap, return failure.		return NULL;	PUT(HDRP(bp), PACK(size, 0)); // Create the header and footer for this new 	PUT(FTRP(bp), PACK(size, 0)); // block, signifying its size and that it is free.	PUT(NEXT_BLKP(bp), PACK(0, 1)); // Create a new epilogue block header.	heap_end = NEXT_BLKP(bp);	return coalesce(bp);}void *coalesce(void *bp){	// printf("Running coalesce\n");	// pointers    void *next_bp = NEXT_BLKP(bp); // next bp    void *prev_bp = PREV_BLKP(bp); // previous bp    void *prev_header = HDRP(prev_bp); // previous header    void *next_header = HDRP(next_bp); // next header    void *current_header = HDRP(bp); // current header    // checks to see if next block pointer equals the heap    // if it does then just returns bp    // in order to stop it from merging with the unused memory    // at the end	if(next_bp == heap_end) {		return bp;	}    // allocation bit    unsigned alloc_bit_prev; // previous allocated bit    unsigned alloc_bit_next; // next allocated bit    alloc_bit_prev = GET_ALLOC(prev_header);    alloc_bit_next = GET_ALLOC(next_header);    // sizes    size_t size = GET_SIZE(current_header); // size of current    size_t n_size; // next size    size_t p_size; // prev size	// printf("PREVIOUS: %lu | ALLOC: %d | SIZE: %d\n", (long)prev_bp, GET_ALLOC(HDRP(prev_bp)), GET_SIZE(HDRP(prev_bp)));	// printf("CURRENT: %lu | ALLOC: %d | SIZE: %d\n", (long)bp, GET_ALLOC(HDRP(bp)), GET_SIZE(HDRP(bp)));	// printf("NEXT: %lu | ALLOC: %d | SIZE: %d\n", (long)next_bp, GET_ALLOC(HDRP(next_bp)), GET_SIZE(HDRP(next_bp)));    // There are 4 cases in a coalesce scenerio    if(alloc_bit_prev == 1 && alloc_bit_next == 1) { // both are already allocated    	// printf("Return bp\n");    	return bp; // returns as both are allocated    }    else if (alloc_bit_prev == 1 && alloc_bit_next == 0) // next is not allocated but prev is    {    	// printf("Return bp with merge sdsadjiosajdiosa next\n");       	// printf("Pointer to the next header is %lu", (long)next_header);    	n_size = GET_SIZE(next_header); // size of next    	// printf("The next size is %d", n_size);    	size += n_size; // add size of next to size of current    	merge(bp); // merges next with current    	return bp;    }    else if (alloc_bit_prev == 0 && alloc_bit_next == 1){ // previous is free    	// printf("Return bp with merge with previous\n");    	p_size = GET_SIZE(prev_header); // size of previous    	size += p_size; // size of previous + size of current    	merge(prev_bp); // merges with previous    	return prev_bp;    }    else { // both are free    	// printf("Return bp with merge with both\n");    	n_size = GET_SIZE(next_header); // gets size of next    	p_size = GET_SIZE(prev_header); // gets size of prev    	size += p_size + n_size; // size of current + size of previous    	merge(bp); // merge current    	merge(prev_bp); // merge before    	return prev_bp;    }}// for sake of efficiency, it will merge the current block (bp)// with the next block. We will passing pointer of the block before// and it will merge with the next block.void merge(void *bp) {	void *next_bp; // pointer to the next pointer 	size_t bp_size; // size of the current block	size_t next_bp_size; // size of the next block	next_bp = NEXT_BLKP(bp); // points next to the next pointer	bp_size = GET_SIZE(HDRP(bp)); // size of the current one	next_bp_size = GET_SIZE(HDRP(next_bp)); // size of the next	PUT(HDRP(bp), PACK(bp_size + next_bp_size, 0)); // changes the header of	// the previous one	PUT(FTRP(next_bp), PACK(bp_size + next_bp_size, 0)); // changes the footer of	// the current one}