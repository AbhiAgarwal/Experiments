/* * mm-naive.c - The fastest, least memory-efficient malloc package. *  * In this naive approach, a block is allocated by simply incrementing * the brk pointer.  A block is pure payload. There are no headers or * footers.  Blocks are never coalesced or reused. Realloc is * implemented directly using mm_malloc and mm_free. * * NOTE TO STUDENTS: Replace this header comment with your own header * comment that gives a high level description of your solution. */#include <stdio.h>#include <stdlib.h>#include <assert.h>#include <unistd.h>#include <string.h>#include "mm.h"#include "memlib.h"/********************************************************* * NOTE TO STUDENTS: Before you do anything else, please * replace the first three fields in the following struct * with your own information (you may choose your own * "team name").  Leave the last two feilds blank. ********************************************************/team_t team = {	/* Team name */	"instructors",	/* First member's full name */	"Abhi Agarwal",	/* First member's NYU NetID*/	"ama684@nyu.edu",	/* Second member's full name (leave blank if none) */	"Max Dumas",	/* Second member's email address (leave blank if none) */	"mfd271@nyu.edu"};/* single word (4) or double word (8) alignment */#define ALIGNMENT 8#define WSIZE     4#define DSIZE	  8#define CHUNKSIZE (1 << 12)/* Macros *//* rounds up to the nearest multiple of ALIGNMENT */#define ALIGN(size) (((size) + (ALIGNMENT-1)) & ~0x7)#define PACK(size, alloc)   ((size) | (alloc))#define MAX(x, y)   ((x) > (y) ? (x) : (y))#define MIN(x, y)   ((x) < (y) ? (x) : (y))#define GET(p)      (*((size_t*) (p)))#define PUT(p, val) (*((size_t*) (p)) = (val))#define GET_SIZE(p)         (GET(p) & ~0x7)#define GET_ALLOC(p)        (GET(p) & 0x1)#define HDRP(bp)    ((char*)(bp) - WSIZE)#define FTRP(bp)    ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)#define NEXT_BLKP(bp)   ((char*)(bp) + GET_SIZE((char*)(bp) - WSIZE))#define PREV_BLKP(bp)   ((char*)(bp) - GET_SIZE((char*)(bp) - DSIZE))#define FREE_NEXT_ADD(bp)   ((char*) ((char*)(bp)))      #define FREE_PREV_ADD(bp)   ((char*) ((char*)(bp) + DSIZE))#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))static void *heap;static void *heap_end;static void *coalesce(void *bp);static void *expand_heap(size_t words);static void *merge(void *bp);/*  * mm_init - initialize the malloc package. */int mm_init(void){	// Get the address of the beginning of the heap, also expand the heap for our initial padding.	heap = mem_sbrk(4 * WSIZE);	// Check if we failed to expand the heap.	if(((long) heap) == -1)		return -1;	PUT(heap, 0);	PUT(heap + WSIZE, PACK(DSIZE, 1));	PUT(heap + DSIZE, PACK(DSIZE, 1));	// Advance the heap to put us at the first "real" block of memory.	heap += DSIZE;	heap_end = heap + WSIZE; // Advance the end of the heap.	// Epilogue, marks the end of the heap. Once again to avoid edge cases.	PUT(heap_end, PACK(0, 1));	// Extend the heap by the chunksize (or at least as close as we can be to it	// and maintain alignment) 	if(expand_heap(CHUNKSIZE/WSIZE) == NULL) 		return -1;	else return 0;}/*  * mm_malloc - Allocate a block by incrementing the brk pointer. *     Always allocate a block whose size is a multiple of the alignment. */void *mm_malloc(size_t size){	if(size <= 0) return NULL;	size_t desir_size;	if(size <= DSIZE)		// If the user wants a block smaller than a double-word, not possible. Give them the minimum.		desir_size = 2 * DSIZE; // Which happens to be the header, 2 word payload, then the footer.	else // Otherwise add to the size the cost of our header/footer, then ensure it maintains alignment.		desir_size = ALIGN(size + DSIZE);	// Now find the first block that fits, and get us the pointer for that!	void *bp = heap + DSIZE; // Get the first payload	// While the current block is either too small or allocated, and we are inside the heap...	while((GET_ALLOC(HDRP(bp)) || desir_size > GET_SIZE(HDRP(bp))) && bp < heap_end)		bp = NEXT_BLKP(bp); // Move to the next one!	// If we reached the end of the heap, then there was no chunk large enough for the	// desired size. So we then allocate a new chunk of CHUNKSIZE or desired size, whichever is bigger.	if(bp >= heap_end) 	{		bp = expand_heap(MAX(desir_size, CHUNKSIZE) / WSIZE);		if(bp == NULL) return NULL;	}	size_t block_size = GET_SIZE(HDRP(bp));	if(block_size > desir_size) // If this, then we have external fragmentation, we need to	{	// split the found block		void *n_bp = bp + desir_size;		size_t n_size = block_size - desir_size;		PUT(n_bp - WSIZE, PACK(n_size, 0)); // Set the header of the free block		PUT(FTRP(bp), PACK(n_size, 0)); // Update the footer of the free block		PUT(n_bp - DSIZE, PACK(desir_size, 1)); // Set the footer of the block we are allocating		PUT(HDRP(bp), PACK(desir_size, 1)); // Update the header of the block we are allocating				coalesce(n_bp);	}	else // the block and desired size are the same	{			PUT(HDRP(bp), PACK(desir_size, 1)); // Set header to the new size 		// (should be the same as the old), but make it allocated.		PUT(FTRP(bp), PACK(desir_size, 1)); // Do likewise with the footer.	}	return bp;}/* * mm_free - Frees the provided non-null pointer, and coalesces it *		with any adjacent free blocks. */void mm_free(void *bp){	if(bp == NULL)		return;	size_t size = GET_SIZE(HDRP(bp));	PUT(HDRP(bp), PACK(size, 0));	PUT(FTRP(bp), PACK(size, 0));	coalesce(bp);}/* *	mm_realloc - Returns a pointer to an allocated region of atleast (SIZE) bytes *		with the following constraints: *		- If BP is null call the equivalent mmalloc(size)  *		- If SIZE == 0 equivalent mm_free bp *		- If BP is not null, realloc changes the size of the memory block pointed  *			to by BP to size bytes and returns the address of the new block *		- The contents of the new block are the same as those of the old block (BP) *			OR up to the minumum of the old and new sizes  */void *mm_realloc(void *bp, size_t size){	void *newbp;	void *oldbp = bp;	if (oldbp == NULL)		return mm_malloc(size);	else if (size != 0) 	{		newbp = mm_malloc(size);		size_t csize = MIN(size, GET_SIZE(HDRP(oldbp)));		memcpy(newbp, oldbp, csize);	}	mm_free(oldbp);    	return newbp;}void *expand_heap(size_t words){	// Get an aligned size based on the requested # of words	size_t size = ALIGN(words * WSIZE);	// Expand the heap by size, get the pointer to the old end of the heap.	void * bp = mem_sbrk(size);	if(((long)bp) == -1) // If we failed to expand the heap, return failure.		return NULL;	PUT(HDRP(bp), PACK(size, 0)); // Create the header and footer for this new 	PUT(FTRP(bp), PACK(size, 0)); // block, signifying its size and that it is free.	void *n_bp = NEXT_BLKP(bp); // Get the end of the heap.	PUT(n_bp, PACK(0, 1)); // Create a new epilogue block header.	heap_end = n_bp; // Make our heap_end point to the new heap end					 // which is the epilogue	return coalesce(bp);}void *coalesce(void *bp){	void *n_bp = NEXT_BLKP(bp); // Next block		// If the next block is the epilogue of the heap	// we don't want to coalesce.	if(n_bp == heap_end)		return bp;	void *p_bp = PREV_BLKP(bp); // Previous block	void *p_header = HDRP(p_bp); // Previous block's header	void *n_hdr = HDRP(n_bp); // Next block's header	unsigned p_alloc = GET_ALLOC(p_header); // Previous block's alloc bit	unsigned n_alloc = GET_ALLOC(n_hdr); // Next block's alloc bit	// There are 4 cases in a coalesce scenario:	if(p_alloc && n_alloc) // Both adjacent blocks are allocated.		return bp; // No coalescing can be done. Return.	else if (!n_alloc) // The next block is free.		return merge(bp); // Merge the current block with the next.	else if (!p_alloc) // The previous block is free.		return merge(p_bp); // Merge the previous block with the current.	else // Both blocks are free.	{		merge(bp); // Merge the current block with the next.		// Merge the previous block with the (current + next) block.		return merge(p_bp); 	}}// for sake of efficiency, it will merge the current block (bp)// with the next block. We will passing pointer of the block before// and it will merge with the next block.void *merge(void *bp) {	void *n_bp = NEXT_BLKP(bp); // pointer to the next pointer 	size_t size = GET_SIZE(HDRP(bp)); // size of the current block	size_t n_size = GET_SIZE(HDRP(n_bp)); // size of the next block	PUT(HDRP(bp), PACK(size + n_size, 0)); // changes the header of	// the previous one	PUT(FTRP(n_bp), PACK(size + n_size, 0)); // changes the footer of	// the current one	return bp;}