/* * mm.c -  * Our implementation uses an implicit free list with boundary tags. * So each "block" of memory has a header and a footer, which consist of * one unsigned integer, which contains an 8-byte aligned size, * and its least significant bit is used to signify if its corresponding block * is allocated. We have used first fit search and immediate coalescing. * * Authors: Max Dumas 		(mfd271) *			Abhi Agarwal 	(ama684) */#include <stdio.h>#include <stdlib.h>#include <assert.h>#include <unistd.h>#include <string.h>#include "mm.h"#include "memlib.h"/********************************************************* * NOTE TO STUDENTS: Before you do anything else, please * replace the first three fields in the following struct * with your own information (you may choose your own * "team name").  Leave the last two feilds blank. ********************************************************/team_t team = {	/* Team name */	"instructors",	/* First member's full name */	"Abhi Agarwal",	/* First member's NYU NetID*/	"ama684@nyu.edu",	/* Second member's full name (leave blank if none) */	"Max Dumas",	/* Second member's email address (leave blank if none) */	"mfd271@nyu.edu"};/* single word (4) or double word (8) alignment */#define ALIGNMENT 8#define WSIZE     4#define DSIZE	  8#define CHUNKSIZE (1 << 12)/* Macros *//* rounds up to the nearest multiple of ALIGNMENT */#define ALIGN(size) (((size) + (ALIGNMENT-1)) & ~0x7)#define PACK(size, alloc)   ((size) | (alloc))#define MAX(x, y)   ((x) > (y) ? (x) : (y))#define MIN(x, y)   ((x) < (y) ? (x) : (y))#define GET(p)      (*((size_t*) (p)))#define PUT(p, val) (*((size_t*) (p)) = (val))#define GET_SIZE(p)         (GET(p) & ~0x7)#define GET_ALLOC(p)        (GET(p) & 0x1)#define HDRP(bp)    ((char*)(bp) - WSIZE)#define FTRP(bp)    ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)#define NEXT_BLKP(bp)   ((char*)(bp) + GET_SIZE((char*)(bp) - WSIZE))#define PREV_BLKP(bp)   ((char*)(bp) - GET_SIZE((char*)(bp) - DSIZE))#define FREE_NEXT_ADD(bp)   ((char*) ((char*)(bp)))      #define FREE_PREV_ADD(bp)   ((char*) ((char*)(bp) + DSIZE))#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))static void *coalesce(void *bp);static void *expand_heap(size_t words);static void *merge(void *bp);static void *heap;static void *heap_end;/*  * mm_init - Initializes the heap by providing a prologue and epilogue to it, *		allocating one chunk into the heap, and placing the heap pointer into 		position. */int mm_init(void){	// Get the address of the beginning of the 	// heap, also expand the heap for our initial padding.	heap = mem_sbrk(4 * WSIZE);	// Check if we failed to expand the heap.	if(((long) heap) == -1)		return -1;	PUT(heap, 0);	PUT(heap + WSIZE, PACK(DSIZE, 1));	PUT(heap + DSIZE, PACK(DSIZE, 1));	// Advance the heap to put us at the first "real" block of memory.	heap += DSIZE;	heap_end = heap + WSIZE; // Advance the end of the heap.	// Epilogue, marks the end of the heap. Once again to avoid edge cases.	PUT(heap_end, PACK(0, 1));	// Extend the heap by the chunksize (or at least as close as we can be to it	// and maintain alignment) 	if(expand_heap(CHUNKSIZE/WSIZE) == NULL) 		return -1;	else return 0;}/*  * mm_malloc - Given a desired SIZE, looks through the heap, block by block, *		searching for the first block that fits. If one is found, the block is *		placed into there. If no block is found, the heap is expanded by one chunk or *		by the desired size, whichever is larger, and the block is allocated there.  *		The remainder of the found block is split off as external fragmentation. */void *mm_malloc(size_t size){	if(size <= 0) return NULL;	size_t desir_size;	if(size <= DSIZE)		// If size smaller than double-word, disallowed. Give them the min.		desir_size = 2 * DSIZE; // Min is the header, 2 word payload, then the footer.	else // Add to the size the cost of our header/footer, then ensure it maintains alignment.		desir_size = ALIGN(size + DSIZE);	// Now find the first block that fits, and get us the pointer for that!	void *bp = heap + DSIZE; // Get the first payload	// While the current block is either too small or allocated, and we are inside the heap...	while((GET_ALLOC(HDRP(bp)) || desir_size > GET_SIZE(HDRP(bp))) && bp < heap_end)		bp = NEXT_BLKP(bp); // Move to the next one!	// If we reached the end of the heap, then there was no chunk large enough for the	// desired size. So we then allocate a new chunk of CHUNKSIZE or desired size, whichever is bigger.	if(bp >= heap_end) 	{		bp = expand_heap(MAX(desir_size, CHUNKSIZE) / WSIZE);		if(bp == NULL) return NULL;	}	size_t block_size = GET_SIZE(HDRP(bp));	if(block_size > desir_size) // If this, then we have external fragmentation, we need to	{	// split the found block		void *n_bp = bp + desir_size;		size_t n_size = block_size - desir_size;		PUT(n_bp - WSIZE, PACK(n_size, 0)); // Set the header of the free block		PUT(FTRP(bp), PACK(n_size, 0)); // Update the footer of the free block		PUT(n_bp - DSIZE, PACK(desir_size, 1)); // Set the footer of the block we are allocating		PUT(HDRP(bp), PACK(desir_size, 1)); // Update the header of the block we are allocating				coalesce(n_bp);	}	else // the block and desired size are the same	{		PUT(HDRP(bp), PACK(desir_size, 1)); // Set header to the new size 		// (should be the same as the old), but make it allocated.		PUT(FTRP(bp), PACK(desir_size, 1)); // Do likewise with the footer.	}	return bp;}/* * mm_free - Frees the provided non-null pointer, and coalesces it *		with any adjacent free blocks. */void mm_free(void *bp){	if(bp == NULL) // If bp is null, there is nothing to free!		return;	size_t size = GET_SIZE(HDRP(bp));	PUT(HDRP(bp), PACK(size, 0)); // Mark the header of bp as free	PUT(FTRP(bp), PACK(size, 0)); // Mark the footer of bp as free	coalesce(bp); // Coalesce the now-free bp with any blocks that are adjacent}/* *	mm_realloc - Returns a pointer to an allocated region of atleast (SIZE) bytes *		with the following constraints: *		- If BP is null call the equivalent mmalloc(SIZE)  *		- If SIZE == 0 equivalent mm_free bp *		- If BP is not null, realloc changes the SIZE of the memory block pointed  *			to by BP to SIZE bytes and returns the address of the new block *		- The contents of the new block are the same as those of the old block (BP) *			OR up to the minimum of the old and new sizes  */void *mm_realloc(void *bp, size_t size){	void *newbp;	newbp = mm_malloc(size); // Allocate the new desired block of memory	if(bp != NULL) // If we were provided a valid block...	{		size_t csize = MIN(size, GET_SIZE(HDRP(bp)));		memcpy(newbp, bp, csize); // Move whatever fits (or exists) 								  // into the new memory block.		mm_free(bp); // Free the old block	}	return newbp;}/* * expand_heap - Expands the heap by WORDS words. Returns null if the *		operating system refuses to expand the heap. Otherwise returns 		the new block added to the end of the heap, coalesced */void *expand_heap(size_t words){	// Get an aligned size based on the requested # of words	size_t size = ALIGN(words * WSIZE);	// Expand the heap by size, get the pointer to the old end of the heap.	void * bp = mem_sbrk(size);	if(((long)bp) == -1) // If we failed to expand the heap, return failure.		return NULL;	PUT(HDRP(bp), PACK(size, 0)); // Create the header and footer for this new 	PUT(FTRP(bp), PACK(size, 0)); // block, signifying its size and that it is free.	void *n_bp = NEXT_BLKP(bp); // Get the end of the heap.	PUT(n_bp, PACK(0, 1)); // Create a new epilogue block header.	heap_end = n_bp; // Make our heap_end point to the new heap end					 // which is the epilogue	return coalesce(bp);}/* * coalesce_heap - Given a valid block pointer, coalesces the  * 		previous and next blocks with the current, if either are free. */void *coalesce(void *bp){	void *n_bp = NEXT_BLKP(bp); // Next block		// If the next block is the epilogue of the heap	// we don't want to coalesce.	if(n_bp == heap_end)		return bp;	void *p_bp = PREV_BLKP(bp); // Previous block	void *p_header = HDRP(p_bp); // Previous block's header	void *n_hdr = HDRP(n_bp); // Next block's header	unsigned p_alloc = GET_ALLOC(p_header); // Previous block's alloc bit	unsigned n_alloc = GET_ALLOC(n_hdr); // Next block's alloc bit	// There are 4 cases in a coalesce scenario:	if(p_alloc && n_alloc) // Both adjacent blocks are allocated.		return bp; // No coalescing can be done. Return.	else if (!n_alloc) // The next block is free.		return merge(bp); // Merge the current block with the next.	else if (!p_alloc) // The previous block is free.		return merge(p_bp); // Merge the previous block with the current.	else // Both blocks are free.	{		merge(bp); // Merge the current block with the next.		// Merge the previous block with the (current + next) block.		return merge(p_bp); 	}}/* * merge - Dumbly merges the given block with the next block, regardless of 		allocation. */void *merge(void *bp) {	void *n_bp = NEXT_BLKP(bp); // Pointer to the next block 	size_t comb_size = GET_SIZE(HDRP(bp)) + GET_SIZE(HDRP(n_bp)); // Size of both blocks combined	// Changes the header of the current block with combined block size	PUT(HDRP(bp), PACK(comb_size, 0)); 	// Changes the footer of the next block with combined block size	PUT(FTRP(n_bp), PACK(comb_size, 0)); 	return bp;}