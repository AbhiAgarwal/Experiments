// COALSCE// http://acsweb.ucsd.edu/~pawang/homepage_PhD/pdfs/Panqu%20Wang-%20Dynamic%20Storage%20Allocation.pdf/* * mm-naive.c - The fastest, least memory-efficient malloc package. *  * In this naive approach, a block is allocated by simply incrementing * the brk pointer.  A block is pure payload. There are no headers or * footers.  Blocks are never coalesced or reused. Realloc is * implemented directly using mm_malloc and mm_free. * * NOTE TO STUDENTS: Replace this header comment with your own header * comment that gives a high level description of your solution. */#include <stdio.h>#include <stdlib.h>#include <assert.h>#include <unistd.h>#include <string.h>#include "mm.h"#include "memlib.h"/********************************************************* * NOTE TO STUDENTS: Before you do anything else, please * replace the first three fields in the following struct * with your own information (you may choose your own * "team name").  Leave the last two feilds blank. ********************************************************/team_t team = {	/* Team name */	"instructors",	/* First member's full name */	"Abhi Agarwal",	/* First member's NYU NetID*/	"ama684@nyu.edu",	/* Second member's full name (leave blank if none) */	"Max Dumas",	/* Second member's email address (leave blank if none) */	"mfd271@nyu.edu"};/* single word (4) or double word (8) alignment */#define ALIGNMENT 8#define WSIZE     4#define DSIZE	  8#define TSIZE     12#define	QSIZE     16#define CHUNKSIZE (1 << 12)// binary tree decleration#define OVERHEAD  8#define BLKSIZE   24#define INISIZE   1016 /* Macros *//* rounds up to the nearest multiple of ALIGNMENT */#define ALIGN_SIZE(size) (((size) + (ALIGNMENT-1)) & ~0x7) // Max and Min Macros#define MAX(x, y)   ((x) > (y) ? (x) : (y))#define MIN(x, y)   ((x) < (y) ? (x) : (y))// Read and Write#define GET(p)      (*((size_t*) (p)))#define PUT(p, val) (*((size_t*) (p)) = (val))// Binary Tree Commmands#define SIZE(p) (GET(p) & ~0x7)#define ALLOC(p) (GET(p) & 0x1)#define PACK(size, alloc)   ((size) | (alloc))// Binary Tree movements#define HEAD(p) ((void *)(p) - SSIZE) #define LEFT(p) ((void *)(p)) #define RIGHT(p)((void *)(p) + SSIZE) #define PRNT(p) ((void *)(p) + DSIZE) #define BROS(p) ((void *)(p) + TSIZE) #define FOOT(p) ((void *)(p) + SIZE(HEAD(p)) - DSIZE) // Binary Tree GET, PREV, NEXT, ALLOC#define GET_SIZE(bp) ((GET(HEAD(bp))) & ~0x7) #define GET_PREV(bp) ((void *)(bp) - SIZE(((void *)(bp) - DSIZE))) #define GET_NEXT(bp) ((void *)(bp) + SIZE(HEAD(bp))) #define GET_ALLOC(bp) (GET(HEAD(bp)) & 0x1) #define GET_LEFT(bp) (GET(LEFT(bp))) #define GET_RIGHT(bp) (GET(RIGHT(bp))) #define GET_PRNT(bp) (GET(PRNT(bp))) #define GET_BROS(bp) (GET(BROS(bp))) #define GET_FOOT(bp) (GET(FOOT(bp)))// PUT Functions INTO TREE#define PUT_HEAD(bp, val) (PUT(HEAD(bp), (int)val)) #define PUT_FOOT(bp, val) (PUT(FOOT(bp), (int)val)) #define PUT_LEFT(bp, val) (PUT(LEFT(bp), (int)val)) #define PUT_RIGHT(bp, val) (PUT(RIGHT(bp), (int)val)) #define PUT_PRNT(bp, val) (PUT(PRNT(bp), (int)val)) #define PUT_BROS(bp, val) (PUT(BROS(bp), (int)val))static void *heap;static void *heap_end;static void *free_tree;static void *coalesce(void *bp);static void *expand_heap(size_t words);static void *merge(void *bp);/*  * mm_init - initialize the malloc package. */int mm_init(void){	// Get the address of the beginning of the heap, also expand the heap for our initial padding.	heap = mem_sbrk(4 * WSIZE);	// Check if we failed to expand the heap.	if(((long) heap) == -1)		return -1;	PUT(heap, 0);	PUT(heap + WSIZE, PACK(DSIZE, 1));	PUT(heap + DSIZE, PACK(DSIZE, 1));	PUT(heap + TSIZE, PACK(0,1) )	// Advance the heap to put us at the first "real" block of memory.	heap += QSIZE;	heap_end = heap + WSIZE; 	// Advance the end of the heap.	// Epilogue, marks the end of the heap. Once again to avoid edge cases.	// Extend the heap by the chunksize (or at least as close as we can be to it	// and maintain alignment) 	free_tree = NULL;	// sets free_tree to NULL	if(expand_heap(ALIGN_SIZE(INISIZE)) == NULL) 		return -1;	else return 0;}/*  * mm_malloc - Allocate a block by incrementing the brk pointer. *     Always allocate a block whose size is a multiple of the alignment. */void *mm_malloc(size_t size){	if(size <= 0) return NULL;	size_t desir_size;	size_t extend_size;	void *bp;	if(size <= BLKSIZE - DSIZE))		// If the user wants a block smaller than a double-word, not possible. Give them the minimum.		desir_size = BLKSIZE; // Which happens to be the header, 2 word payload, then the footer.	else // Otherwise add to the size the cost of our header/footer, then ensure it maintains alignment.		desir_size = ALIGN_SIZE(size + DSIZE);	if((bp = find_fit(desir_size)) == NULL) {		extend_size = MAX(desir_size + 32, INISIZE);		expand_heap(ALIGN_SIZE(extend_size));		if((bp = find_fit(desir_size)) == NULL){			return NULL		}	}	if(size == 448 && GET_SIZE(bp) > desir_size + 64){		desir_size += 64;	}	else if(size == 112 && GET_SIZE(bp) > desir_size + 16){		desir_size += 16;	}	place(bp, desir_size);	return bp;}/* * mm_free - Frees the provided non-null pointer, and coalesces it *		with any adjacent free blocks. */void mm_free(void *bp){	if(bp == NULL)		return;	size_t size = GET_SIZE(bp);	PUT_HEAD(bp, PACK(size, 0));	PUT_FOOT(bp, PACK(size, 0));	insert_node(coalesce(bp));}/* *	mm_realloc - Returns a pointer to an allocated region of atleast (SIZE) bytes *		with the following constraints: *		- If BP is null call the equivalent mmalloc(size)  *		- If SIZE == 0 equivalent mm_free bp *		- If BP is not null, realloc changes the size of the memory block pointed  *			to by BP to size bytes and returns the address of the new block *		- The contents of the new block are the same as those of the old block (BP) *			OR up to the minumum of the old and new sizes  */void *mm_realloc(void *bp, size_t size){	if(bp == NULL || size == 0) {		mm_free(bp);		return NULL;	}	if (size > 0){		size_t oldsize = GET_SIZE(bp);		size_t newsize = ALIGN_SIZE(size + OVERHEAD);		if(newsize < oldsize) {			if(GET_ALLOC(GET_NEXT(bp))){				if((oldsize - newsize) >= BLKSIZE){					PUT_HEAD(bp, PACK(newsize, 1));					PUT_FOOT(bp, PACK(newsize, 1));					void *tmp = GET_NEXT(bp);					PUT_HEAD(tmp, PACK(oldsize - newsize, 0));					PUT_HEAD(tmp, PACK(oldsize - newsize, 0));					insert_node(tmp);				}				else {					PUT_HEAD(bp, PACK(oldsize, 1));					PUT_FOOT(bp, PACK(oldsize ,1));				}				return bp;			}			else {				size_t c_size = oldsize + GET_SIZE(GET_NEXT(bp));				delete_node(GET_NEXT(bp));				PUT_HEAD(bp, PACK(newsize, 1));				PUT_FOOT(bp, PACK(newsize, 1));				void *tmp = GET_NEXT(bp);				PUT_HEAD(tmp, PACK(c_size - newsize));				PUT_FOOT(tmp, PACK(c_size - newsize));				insert_node(tmp);				return bp;			}		}		else {			size_t prev = GET_ALLOC(GET_PREV(bp));			size_t nex  = GET_ALLOC(GET_NEXT(bp));			size_t c_size;			if(!nex && ((c_size = oldsize + GET_SIZE(GET_NEXT(bp))) >= newsize)){				delete_node(GET_NEXT(bp));				if((c_size - newsize) >= BLKSIZE){					PUT_HEAD(bp, PACK(newsize, 1));					PUT_FOOT(bp, PACK(newsize, 1));					void *tmp = GET_NEXT(bp);					PUT_HEAD(tmp, PACK(c_size - newsize, 0));					PUT_FOOT(tmp, PACK(c_size - newsize, 0));					insert_node(tmp);				}				else				{					PUT_HEAD(bp, PACK(c_size, 1));					PUT_FOOT(bp, PACK(c_size, 1));				}				return bp;			}			else if(!prev && ((csize = oldsize + GET_SIZE(GET_PREV(bp))) >= newsize)))				{					delete_node(GET_PREV(bp));					void *temp = GET_PREV(bp);					memcpy(tmp, bp, (oldsize - OVERHEAD));					if(c_size - newsize) >= BLKSIZE){						PUT_HEAD(tmp, PACK(newsize, 1));						PUT_FOOT(tmp, PACK(newsize, 1));						void *tmp1 = GET_NEXT(bp);						PUT_HEAD(tmp1, PACK(c_size - newsize, 0));						PUT_FOOT(tmp1, PACK(c_size - newsize, 0));						insert_node(tmp1);					}					else {						PUT_HEAD(tmp, PACK(c_size, 1));						PUT_FOOT(tmp, PACK(c_size, 1));					}					return tmp;				}			else {				size_t size_align = ALIGN_SIZE(size + (OVERHEAD)); 				size_t size_ext;				void *tmps;				if((tmps = find_fit(size_align)) == NULL) {					size_ext = MAX(size_align, CHUNKSIZE);					expand_heap(expand_heap);					if((tmps = find_fit(size_align)) == NULL)						return NULL;				}					place(tmps, size_align);					memcpy(tmps, bp, oldsize - OVERHEAD);					mm_free(bp);					return tmps;				}			}		}	else	{		return NULL;	}}void *expand_heap(size_t words){	// Get an aligned size based on the requested # of words	size_t size = ALIGN(words * WSIZE);	// Expand the heap by size, get the pointer to the old end of the heap.	void *bp = mem_sbrk(size);	if(((long)bp) == -1) // If we failed to expand the heap, return failure.		return NULL;	PUT_HEAD(bp, PACK(size, 0)); // Create the header and footer for this new 	PUT_FOOT(bp, PACK(size, 0)); // block, signifying its size and that it is free.	void *n_bp = GET_NEXT(bp); // Get the end of the heap.	PUT_HEAD(n_bp, PACK(0, 1)); // Create a new epilogue block header.	heap_end = n_bp; // Make our heap_end point to the new heap end					 // which is the epilogue	insert_node(coalesce(bp));	return (void *)bp;}void *coalesce(void *bp){	void *n_bp = NEXT_BLKP(bp); // Next block		// If the next block is the epilogue of the heap	// we don't want to coalesce.	if(n_bp == heap_end)		return bp;	void *p_bp = PREV_BLKP(bp); // Previous block	void *p_header = HDRP(p_bp); // Previous block's header	void *n_hdr = HDRP(n_bp); // Next block's header	unsigned p_alloc = GET_ALLOC(p_header); // Previous block's alloc bit	unsigned n_alloc = GET_ALLOC(n_hdr); // Next block's alloc bit	// There are 4 cases in a coalesce scenario:	if(p_alloc && n_alloc) // Both adjacent blocks are allocated.		return bp; // No coalescing can be done. Return.	else if (!n_alloc) // The next block is free.		return merge(bp); // Merge the current block with the next.	else if (!p_alloc) // The previous block is free.		return merge(p_bp); // Merge the previous block with the current.	else // Both blocks are free.	{		merge(bp); // Merge the current block with the next.		// Merge the previous block with the (current + next) block.		return merge(p_bp); 	}}// for sake of efficiency, it will merge the current block (bp)// with the next block. We will passing pointer of the block before// and it will merge with the next block.void *merge(void *bp) {	void *n_bp = NEXT_BLKP(bp); // pointer to the next pointer 	size_t size = GET_SIZE(HDRP(bp)); // size of the current block	size_t n_size = GET_SIZE(HDRP(n_bp)); // size of the next block	PUT(HDRP(bp), PACK(size + n_size, 0)); // changes the header of	// the previous one	PUT(FTRP(n_bp), PACK(size + n_size, 0)); // changes the footer of	// the current one	return bp;}